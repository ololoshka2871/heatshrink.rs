/* automatically generated by rust-bindgen 0.59.1 */
pub(crate) const HEATSHRINK_AUTHOR: &'static [u8; 32usize] = b"Scott Vokes <vokes.s@gmail.com>\0";
pub(crate) const HEATSHRINK_URL: &'static [u8; 43usize] =
    b"https://github.com/atomicobject/heatshrink\0";
pub(crate) const HEATSHRINK_VERSION_MAJOR: u32 = 0;
pub(crate) const HEATSHRINK_VERSION_MINOR: u32 = 4;
pub(crate) const HEATSHRINK_VERSION_PATCH: u32 = 1;
pub(crate) const HEATSHRINK_MIN_WINDOW_BITS: u32 = 4;
pub(crate) const HEATSHRINK_MAX_WINDOW_BITS: u32 = 15;
pub(crate) const HEATSHRINK_MIN_LOOKAHEAD_BITS: u32 = 3;
pub(crate) const HEATSHRINK_LITERAL_MARKER: u32 = 1;
pub(crate) const HEATSHRINK_BACKREF_MARKER: u32 = 0;
pub(crate) const HEATSHRINK_STATIC_INPUT_BUFFER_SIZE: u32 = 32;
pub(crate) const HEATSHRINK_STATIC_WINDOW_BITS: u32 = 8;
pub(crate) const HEATSHRINK_STATIC_LOOKAHEAD_BITS: u32 = 4;
pub(crate) const HEATSHRINK_DEBUGGING_LOGS: u32 = 0;
pub(crate) const HEATSHRINK_USE_INDEX: u32 = 1;

pub(crate) type size_t = usize;

pub(crate) const HSE_sink_res_HSER_SINK_OK: HSE_sink_res = 0;
pub(crate) const HSE_sink_res_HSER_SINK_ERROR_NULL: HSE_sink_res = -1;
pub(crate) const HSE_sink_res_HSER_SINK_ERROR_MISUSE: HSE_sink_res = -2;
pub(crate) type HSE_sink_res = i32;
pub(crate) const HSE_poll_res_HSER_POLL_EMPTY: HSE_poll_res = 0;
pub(crate) const HSE_poll_res_HSER_POLL_MORE: HSE_poll_res = 1;
pub(crate) const HSE_poll_res_HSER_POLL_ERROR_NULL: HSE_poll_res = -1;
pub(crate) const HSE_poll_res_HSER_POLL_ERROR_MISUSE: HSE_poll_res = -2;
pub(crate) type HSE_poll_res = i32;
pub(crate) const HSE_finish_res_HSER_FINISH_DONE: HSE_finish_res = 0;
pub(crate) const HSE_finish_res_HSER_FINISH_MORE: HSE_finish_res = 1;
pub(crate) const HSE_finish_res_HSER_FINISH_ERROR_NULL: HSE_finish_res = -1;
pub(crate) type HSE_finish_res = i32;

// Индекс
#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct hs_index {
    size: u16,
    // размер в 2 раза больше входного буфера (heatshrink-dist/heatshrink_encoder.c: 92)
    index: [u16; (2 << HEATSHRINK_STATIC_WINDOW_BITS) as usize],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub(crate) struct _heatshrink_encoder {
    input_size: u16,
    match_scan_index: u16,
    match_length: u16,
    match_pos: u16,
    outgoing_bits: u16,
    outgoing_bits_count: u8,
    flags: u8,
    state: u8,
    current_byte: u8,
    bit_index: u8,
    search_index: hs_index,
    // Входной буфер
    buffer: [u8; (2 << HEATSHRINK_STATIC_WINDOW_BITS) as usize],
}

extern "C" {
    pub(crate) fn heatshrink_encoder_reset(hse: *mut _heatshrink_encoder);
    pub(crate) fn heatshrink_encoder_sink(
        hse: *mut _heatshrink_encoder,
        in_buf: *const u8,
        size: size_t,
        input_size: *mut size_t,
    ) -> HSE_sink_res;
    pub(crate) fn heatshrink_encoder_poll(
        hse: *mut _heatshrink_encoder,
        out_buf: *mut u8,
        out_buf_size: size_t,
        output_size: *mut size_t,
    ) -> HSE_poll_res;
    pub(crate) fn heatshrink_encoder_finish(hse: *mut _heatshrink_encoder) -> HSE_finish_res;
}
